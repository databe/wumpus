--------------------------------------------------------------------------------------------------------------------------------------------
INSTALACIÓN, ESPECIFICACIONES...:
--------------------------------------------------------------------------------------------------------------------------------------------

* Python >= 3.6 y pipenv instalados.

* Dentro del directorio 'testAmaris', ejecutar: 'pipenv shell' y activamos el Entorno Virtual. 

* Versión de Python = 3.9.7. Para versiones de Python > 3.6, la versión mínima de NumPy que funciona es la 1.21.0

* He empleado VS Code



--------------------------------------------------------------------------------------------------------------------------------------------
JUEGO:
--------------------------------------------------------------------------------------------------------------------------------------------

* Las especificaciones relativas a las casillas se cumplen.


* Las especificaciones relativas al usuario se cumplen.


* Las celdas, pozos y flechas vienen parametrizadas por el valor que el usuario introduce:

    - El usuario ha de introducir un número N > 2. Esto determina número de celdas y por tanto el tamaño del tablero. Por ejemplo, si introduce N=3, el tablero es de 3x3, etc.

    - He decidido parametrizar todos los elementos del tablero en base a N. El usuario solo parametriza el tamaño del tablero.

      En este sentido, habrán N-1 pozos, y N/2 flechas. (Como N es un número entero, si es impar, el número de flechas será redondeado; N=3, flechas=1. Si N=4, flechas=2).


* Añadidos logs de acciones y resultados obtenidos (tablero inicial y final).


* Existen 2 tableros: tablero y tablero_sorteo.

    - El primero (tablero) es el tablero 'de verdad', el de la partida. Es una matriz NxN y en cada celda hay un diccionario Python con los diferentes valores.

    - El segundo (tablero_sorteo) es una matriz igual de NxN pero en lugar de contener diccionarios, únicamente contiene la id del elemento que hay en cada celda.
      
      Sirve para montar el tablero del juego y luego para llevar un control de la partida en el log ().


* COMANDOS:
    - [W + ENTER]: Avanzar 1 casilla.
    - [D + ENTER]: Girar 90º Derecha.
    - [A + ENTER]: Girar 90º Izquierda.
    - [S + ENTER]: Lanzar flechas.
    - [Q + ENTER]: Salir (sólo desde la casilla de salida): Solo compruebo si el jugador se encuentra en la casilla de salida:

        Si tiene el oro, obviamente este es el objetivo hipotético del juego. Pero si no tiene el oro podría salir si se encuentra en la casilla de salida.
        En las acciones que puede realizar el usuario (pág. 4 del pdf) únicamente dice que puede salir si se encuentra en la casilla de salida vivo). 



--------------------------------------------------------------------------------------------------------------------------------------------
TESTS:
--------------------------------------------------------------------------------------------------------------------------------------------

    * En cuanto a los tests, anteriormente ya había hecho tests unitarios, no en mucha profundidad, pero he hecho.

      - En este sentido, el juego lo he programado de forma recursiva y además el programa es text-based donde los parámetros se pasan por consola. No sabía muy bien como plantear los test para esto.
      Las funciones son parte de la clase, y está programado recursivamente de forma que al generar una instancia de la clase Partida, esta llama al método crear_partida() e inicia el 'proceso' por consola.

      Por ello había decidido hacer un único test que lea de la consola los mensajes/pistas que el programa muestra al usuario y, si coincidían, dar el test por bueno. No me ha sido tan fácil como pensaba y no lo he conseguido.

      Pero quería dejar claro cómo lo había pensado hacer inicialmente. Empleando las librerías pytest, subprocess...

      (Me gustaría que me comentaran, si es posible, como plantear tests a un programa como este).
    